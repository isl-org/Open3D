material {
    name : defaultLit,
    shadingModel : lit,
    doubleSided : true,
    parameters : [
        { type : float3,    name : baseColor },
        { type : float,     name : baseMetallic },
        { type : float,     name : baseRoughness },
        { type : float,     name : reflectance },
        { type : float,     name : pointSize },
        { type : float,     name : clearCoat },
        { type : float,     name : clearCoatRoughness },
        { type : float,     name : anisotropy },
        { type : sampler2d, name : albedo },
        { type : sampler2d, name : ao_rough_metalMap },
        { type : sampler2d, name : normalMap },
        { type : sampler2d, name : reflectanceMap },
        { type : sampler2d, name : anisotropyMap },
        { type : int,       name : shDegree }
    ],
    variables : [
        colorFromSh,
        test1,
        test2,
        test3
    ],
    requires : [
        color,    // scale
        tangents, // rot
        custom0,  // f_dc and opacity
        custom1,  // custom1-custom6 store f_rest_0-f_rest_23 SH coeffs
        custom2,
        custom3,
        custom4,
        custom5,
        custom6
    ]
}

vertex {
    #include "../../shader/glsl/ShCoeffsToColorFast.glsl"

    void materialVertex(inout MaterialVertexInputs material) {
        gl_PointSize = materialParams.pointSize;

        // refering to https://google.github.io/filament/Materials.html#materialdefinitions/shaderpublicapis/vertexonly,
        // the worldPosition coordinate in the vertex shader is shifted by the camera position.
        vec3 dir = material.worldPosition.xyz;

        // According to "../../shader/glsl/ShCoeffsToColorFast.glsl", the coeffs should be in the following order:
        // [Y0_R, Y0_G, Y0_B, Y1m1_R, Y1m1_G, Y1m1_B, Y10_R, Y10_G, Y10_B, Y11_R, Y11_G, Y11_B, Y2m2_R, Y2m2_G, Y2m2_B, ...]
        float coeffs[25 * 3];

        for (int i = 0; i < 25 * 3; i++) {
            coeffs[i] = 0.0;
        }

        float4 f_dc_and_opacity = getCustom0();
        coeffs[0] = f_dc_and_opacity.r;
        coeffs[1] = f_dc_and_opacity.g;
        coeffs[2] = f_dc_and_opacity.b;

        vec4 fRest[6];
        fRest[0] = getCustom1();
        fRest[1] = getCustom2();
        fRest[2] = getCustom3();
        fRest[3] = getCustom4();
        fRest[4] = getCustom5();
        fRest[5] = getCustom6();

        for (int i = 0; i < 6; i++) {
            coeffs[3+ i * 4 + 0] = fRest[i].x;
            coeffs[3+ i * 4 + 1] = fRest[i].y;
            coeffs[3+ i * 4 + 2] = fRest[i].z;
            coeffs[3+ i * 4 + 3] = fRest[i].w;
        }

        float colors[3];
        for (int c = 0; c < 3; c++) {
            sh_coeffs_to_color_fast(materialParams.shDegree, c, dir, coeffs, colors);
        }

        material.colorFromSh.r = colors[0];
        material.colorFromSh.g = colors[1];
        material.colorFromSh.b = colors[2];
        material.colorFromSh.a = 0.0;

        // The following code is just used for verifing we can get data from different buffer.
        // material.test1 = getTangents();
        material.test2 = getCustom1();
        material.test3 = getCustom6();
    }
}

fragment {
    void material(inout MaterialInputs material) {
        prepareMaterial(material);

        // The following code is only used to test we can get colorFromSh from vertex shader.
        float r = 0.0;
        float g = 0.0;
        float b = 0.0;
        material.baseColor.rgb = vec3(r, g, b);
        
        material.baseColor.rgb = variable_colorFromSh.rgb;

        // Wrong Case1: Calculate RGB value using color directly.
        // material.baseColor.rgb = getColor().rgb;
  
        // Wrong Case2: Calculate RGB value using world position.
        // material.baseColor.rgb = getWorldPosition();

        // Wrong Case3: Calculate RGB value using user world position.
        // material.baseColor.rgb = getUserWorldPosition();

        // test case1: Check we can get data rot, this does not work for now.
        // material.baseColor.rgb = variable_test1.rgb;

        // test case2: Check we can get data f_rest for order 1
        // material.baseColor.rgb = variable_test2.rgb;

        // test case3: Check we can get data f_rest for order 2
        // material.baseColor.rgb = variable_test3.rgb;

        // test case3: Check we can get data scale
        // material.baseColor.rgb = getColor().rgb;
    }
}